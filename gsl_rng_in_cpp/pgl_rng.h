
#ifndef PGL_RNG_H
#define PGL_RNG_H
#include <iostream>

#include <string>
using std::string;
using std::cout;

struct pgl_rng_type{
    // const char * name;
    // unsigned long int max;
    // unsigned long int min;
    // size_t size;
    // void (*set) (void * state, unsigned long int seed);
    // unsigned long int (*get) (void * state);
    // double (*get_double) (void *state);
};

struct pgl_rng{
    void * state;
    const pgl_rng_type * type;
    bool seeded;

    virtual void set(unsigned int seed){error();}
    virtual void set(unsigned int * seed){error();}
    virtual void set(const unsigned char * seed){error();}
    virtual void set_type(string){error();}
    virtual unsigned long int get_long(){error();}
    virtual double get_double(){error();}
    void error(){
        cout << "This function is not supported.\n";
        exit(1);
    }
};

const pgl_rng_type * pgl_rng_dsfmt = new pgl_rng_type();     
const pgl_rng_type * pgl_rng_mad0 = new pgl_rng_type();
const pgl_rng_type * pgl_rng_tinymt = new pgl_rng_type();
const pgl_rng_type * pgl_rng_well = new pgl_rng_type();
const pgl_rng_type * pgl_rng_xorgens = new pgl_rng_type();

const unsigned long int pgl_rng_default_seed = 0;

#include "pglrng_dsfmt.h"
#include "pglrng_mad0.h"
#include "pglrng_tinymt.h"

pgl_rng * pgl_rng_alloc(const pgl_rng_type * T){
    /*
        This function returns a pointer to a newly-created instance 
        of a random number generator of type T. For example, the 
        following code creates an instance of the dsfmt generator,

            gsl_rng * r = pgl_rng_alloc (pgl_rng_dsfmt);

        The generator is automatically initialized with the default seed, 
        gsl_rng_default_seed. This is zero by default but can be changed 
        either directly or by using the environment variable PGL_RNG_SEED.
    */
    pgl_rng * r;

    if(T == pgl_rng_dsfmt){
        r = new pglrng_dsfmt();
    } else if(T == pgl_rng_mad0){
        r = new pglrng_mad0();
    } else if(T == pgl_rng_tinymt){
        r = new pglrng_tinymt();
    } else if(T == pgl_rng_well){

    } else if(T == pgl_rng_xorgens){

    }

    r->type = T;
    r->seeded = false;

    return r;
}

void pgl_rng_free (pgl_rng * r){
    /*
        This function frees all the memory associated with the generator r.
    */
    delete r->state;
    delete r;
}

void pgl_rng_set (pgl_rng * r, unsigned long int s){
    /*
        This function initializes (or ‘seeds’) the random number generator. 
        If the generator is seeded with the same value of s on two different 
        runs, the same stream of random numbers will be generated by 
        successive calls to the routines below. If different values of s >= 1 
        are supplied, then the generated streams of random numbers should 
        be completely different. If the seed s is zero then the standard seed 
        from the original implementation is used instead.
    */
    r->set(s);
    r->seeded = true;
}

void pgl_rng_set (pgl_rng * r, const unsigned char * s){
    /*
        NOTE: This function is to be used with the MaD0 generator.
        This function initializes (or ‘seeds’) the random number generator. 
        If the generator is seeded with the same value of s on two different 
        runs, the same stream of random numbers will be generated by 
        successive calls to the routines below. If different values of s >= 1 
        are supplied, then the generated streams of random numbers should 
        be completely different. If the seed s is zero then the standard seed 
        from the original implementation is used instead.
    */
    r->set(s);
    r->seeded = true;
}

unsigned long int pgl_rng_get (pgl_rng * r){
    /*
        This function returns a random integer from the generator r.
    */
    if(!r->seeded){
        std::cout << "rng was not seeded; now seeded with default value" << std::endl;
        pgl_rng_set(r, pgl_rng_default_seed);
    }
    return r->get_long();
}

double pgl_rng_uniform (pgl_rng * r){
    /*
        This function returns a double precision floating point number 
        uniformly distributed in the range [0,1).
    */
    if(!r->seeded){
        std::cout << "rng was not seeded; now seeded with default value" << std::endl;
        pgl_rng_set(r, pgl_rng_default_seed);
    }
    return r->get_double();
}

double gsl_rng_uniform_pos (pgl_rng * r){
    /*
        This function returns a positive double precision floating 
        point number uniformly distributed in the range (0,1), 
        excluding both 0.0 and 1.0. The number is obtained by 
        sampling the generator with the algorithm of 
        gsl_rng_uniform until a non-zero value is obtained. You can 
        use this function if you need to avoid a singularity at 0.0.
    */
    if(!r->seeded){
        std::cout << "rng was not seeded; now seeded with default value" << std::endl;
        pgl_rng_set(r, pgl_rng_default_seed);
    }
    double returnMe = r->get_double();
    while(returnMe == 0.0){
        returnMe = r->get_double();
    }
    return returnMe;
}

const char * pgl_rng_name (const pgl_rng_type * T){
    /*
        This function returns a pointer to the name of the generator.
    */

    if(T == pgl_rng_dsfmt){
        return "dsfmt";
    } else if(T == pgl_rng_mad0){
        return "mad0";
    } else if(T == pgl_rng_tinymt){
        return "tinymt";
    } else if(T == pgl_rng_well){
        return "well";
    } else if(T == pgl_rng_xorgens){
        return "xorgens";
    }
}

const char * pgl_rng_name (pgl_rng * r){
    /*
        This function returns a pointer to the name of the generator.
    */
    return pgl_rng_name(r->type);
}

#endif